#!/bin/sh

#
# basics
#
alias ...='cd ../..'
alias ..='cd ..'
alias cp='cp -i'
alias e='emacs -nw'
alias exa='exa --group-directories-first'
alias j='jobs -l'
alias c='bat -p'
alias h='head'
alias le='bat -p --paging=always'
alias l='ls'
alias ll='ls -la'
alias mv='mv -i'
alias rm='rm -i'
alias ln='ln -i'
alias celar='clear'  # oh the struggles of life
alias sudo='sudo '  # allow for sudo completion
alias t='tmux'
alias f='fg'
alias utc='TZ=":UTC" date'
alias tls='tmux ls'
alias r='ranger'
ta() {
  if [ -z "$@" ]; then
    tmux attach
  else
    tmux attach -t "$@"
  fi
}
alias v=vim
alias aa='v ~/.aliasrc'
alias bb='v ~/.bashrc'
alias vv='v ~/.vimrc'
alias zz='v ~/.zshrc'
# Allow watch and xargs alias completion with space.
# https://unix.stackexchange.com/a/25329/162041
alias watch='watch --color -d'
alias xargs='xargs '
if command -v exa > /dev/null; then
  alias ls='exa -F --group-directories-first'
  alias lst='ls -T -L2'
else
  alias lst='tree -L 2'
fi
# _j() {
#   case "$SHELL" in
#     *zsh) echo "%$1";;
#     *bash) echo "$1";;
#   esac
# }
# alias fg='fg $(_j $1)'
# alias bg='bg $(_j $1)'

#
# misc
#
bup() {
  set -x
  brew upgrade
  brew cleanup
}
cup() {
  set -x
  rustup update nightly
  cargo install-update -a
}
alias cv='command -V'
div() {
  tput setaf 4
  tput bold
  printf "%$(tput cols)s\n" | tr " " =
  tput sgr0
}
alias path="echo $PATH | tr ':' '\n'"
alias rg='rg -M 512 --no-heading'
ports() {
  lsof -iTCP -sTCP:LISTEN -n -P
}
# reload the shell
rld() {
  case "$SHELL" in
    *zsh) . ~/.zshrc;;
    *bash) . ~/.bashrc;;
  esac
}
# search aliases, and print them out in columns
ra() {
  alias | rg "$@" | rg "(\w+)='(.*)'" -r '$1%%$2' | column -t -s'%%'
}
# simple and quick HTTP server
serve() {
  local PORT="${1:-8000}"
  echo "http://localhost:$PORT"
  python3 -m http.server "$PORT" --bind 127.0.0.1
}

# Show what an alias or function is.
wh() {
  out=$(command -V $1)
  echo $out
  echo $out | grep -q 'is a shell function' && declare -f $1
}

lab() {
  cd ~/g/drive/notebooks || return
  . ./env/bin/activate
  jupyter notebook
}


#
# k8s + gcloud
#
alias gup='sudo gcloud components update'
alias k='kubectl'
alias kn='kubectl get no'
alias kpa='kp -a'
alias mkl='minikube service list'
alias wpa='wp -a'
# search for k8s pods
kp() {
  if [ -z "$1" ]; then
    kubectl get pods
  elif [ "$1" = '-a' ]; then
    kubectl get pods --all-namespaces
  else
    local PAT
    PAT="$(echo "$@" | tr -s ' ' '|')"
    HEADER=kubectl get pods --all-namespaces | head -1
    kubectl get pods --all-namespaces | rg -N --color=always "$PAT"
  fi
}
# watch k8s pods
wp() {
  export -f kp
  watch kp "$@"
}
# like kp but for deployments
kd() {
  if [ -z "$1" ]; then
    kubectl get deploy
  elif [ "$1" = '-a' ]; then
    kubectl get deploy --all-namespaces
  else
    local PAT="$(echo "$@" | tr -s ' ' '|')"
    kubectl get deploy --all-namespaces | head -1
    kubectl get deploy --all-namespaces | rg -N --color=always "$PAT"
  fi
}
# watch deployments
wd() {
  export -f kd
  watch kd "$@"
}

#
# golang
#
alias goi='go install -v ./...'
alias gome='cd $FIRSTGOPATH/src/github.com/henrywallace'
gdoc() {
  echo http://localhost:6060
  godoc -play -notes="TODO|HELP|QUESTION|NOTE" -http :6060
}
gimp() {
  go list -f '{{ join .Imports "\n" }}' "$@" \
    | sort \
    | uniq -c \
    | sort -nk1
}

#
# git
#
gprune() {
  # include latest tag
  git branch --merge master \
    | grep -v master \
    | xargs git branch -d 2> /dev/null \
  || echo "No branches to prune."
}
alias con='rg "<<<<<<<" $(git rev-parse --show-toplevel)'
alias g-='git checkout -'
alias ga='git add -u'
alias a='git add -u'
alias gp='git pull --rebase'
alias fold='git stash --keep-index && git stash'
alias gua='git reset --soft HEAD@{1} && git reset'

alias gd='git diff'
alias gdc='git diff --cached'
alias gdd='git diff --stat $(git merge-base master HEAD)'
alias gds='echo; git diff --stat; echo'
alias gf='git diff --name-only $(git merge-base master HEAD)'

alias gm='git branch -m'
alias gmp='git checkout master && git pull && gprune'
alias gn='git checkout -b'

alias gr='git rebase master'
alias rc='git rebase --continue'

alias pu='git push origin HEAD'
alias fpu='git push -f origin HEAD'

alias gs=~/bin/git-status
alias g=~/bin/git-status
alias s='~/bin/git-status'
gk() {
  if [ -z "$@" ]; then
    git commit
  else
    git commit -m "$@"
  fi
}
alias lg='git log --reverse --oneline $(git merge-base master HEAD)..HEAD --color=always'
alias clg='clear; lg'
alias lgs='git log --oneline --stat $(git merge-base master HEAD)..HEAD'
alias gl='git log $(git merge-base master HEAD)..HEAD'
alias gls='git log --stat $(git merge-base master HEAD)..HEAD'
alias lgp='git log --relative -p $(git merge-base master HEAD)..HEAD'
alias llg='git log --graph --oneline'

alias lr='git show HEAD --stat'
alias lrp='git show HEAD'


alias p='git stash show -p'
alias st='git stash --keep-index'
alias stl='git stash list'
alias stp='git stash pop'
# rebase master or rebase back $1 commits
rb () {
  if [ -z "$1" ]; then
    git rebase -i "$(git merge-base master HEAD)"
  elif [[ "$1" =~ -[[:digit:]]+ ]]; then
    echo git rebase -i "HEAD~$1"
    git rebase -i "HEAD~$1"
  else
    echo git rebase -i "$1"
    git rebase -i "$1"
  fi
}
# git commit amend, with quick option for no-edit
gca() {
  if [ "$1" = "-" ]; then
    git commit --amend --no-edit --allow-empty
  else
    git commit --amend --allow-empty
  fi
}
# pretty git branches
alias gb=~/bin/git-branches
alias b=gb
# gb() {
#   git rev-parse --is-inside-work-tree > /dev/null || return
#   fmt='%(HEAD)|%(color:green)%(committerdate:relative)%(color:reset)|%(color:blue)%(refname:short)%(color:reset)|%(contents:subject)'
#   branches="$(git for-each-ref --color=always --sort=-committerdate refs/heads/ --format=$fmt)"
#   echo "num branches: $(echo "$branches" | wc -l | xargs)"
#   echo "num stash:    $(git stash list | wc -l | xargs)"
#   if [[ -z "$1" ]]; then
#     echo "$(echo "$branches" | column -t -s '|')"
#   elif [[ "$1" =~ -[[:digit:]]+ ]]; then
#     echo "$(echo "$branches" | head "$1" | column -t -s '|')"
#   elif [[ "$1" == "-" ]]; then
#     echo "$(echo "$branches" | column -t -s '|')"
#   else
#     echo "$(echo "$branches" | rg -N "$1" | column -t -s '|')"
#   fi
# }

grst() {
  remote="$REMOTE"
  if [ -z "$remote" ]; then
    remote=origin
  fi
  git fetch "$remote" && git reset --hard "$remote/$(git branch | rg '\* (.*)' -or '$1')"
}

grb() {
  return
  root="$(git rev-parse --show-toplevel)"
  [[ -d "$root/.git/rebase-merge" ]] || [[ -d "$root/.git/rebase-apply" ]] || echo "Not rebasing" && return
  rebase="$(basename "$(find $root/.git/ -name 'rebase*')")"
  cat "$root/.git/$rebase/done" > /tmp/rebase-done
  cat "$root/.git/$rebase/git-rebase-todo" | rg '^[^#]' | sed '/^\s*$/d' > /tmp/rebase-todo
  num_done="$(wc -l /tmp/rebase-done | awk '{print $1}')"
  num_todo="$(wc -l /tmp/rebase-todo | awk '{print $1}')"
  echo "Branch: $(git branch | rg 'rebasing (.*)\)' -or '$1')"
  echo "Progress: ($num_done/$((num_done + num_todo)))"
  bat /tmp/rebase-done
  conflicts && echo
  bat /tmp/rebase-todo
}
gbs() {
  ref="$1"
  if [[ -z "$ref" ]]; then
    ref=HEAD
  fi
  git diff $(git merge-base master $ref)..$ref
}
